import { jsPDF } from 'jspdf';
import type { Brief } from '@/lib/db/schema/brief';
import { formatDate } from '@/lib/utils/formatting/date';

// Export format types
export type ExportFormat = 'md' | 'pdf';

/**
 * Convert brief content to markdown format
 */
export const briefToMarkdown = (brief: Brief): string => {
  // Get the current date for the attribution line
  const generatedDate = formatDate(new Date());
  
  // Get the review content
  const reviewContent = brief.review || 'No review content available.';
  
  // Find the first heading and insert the attribution line after it
  const lines = reviewContent.split('\n');
  let firstHeadingIndex = -1;
  
  // Look for the first heading (# heading)
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].startsWith('# ')) {
      firstHeadingIndex = i;
      break;
    }
  }
  
  let processedReview = '';
  
  if (firstHeadingIndex >= 0) {
    // Insert attribution after the first heading
    const beforeHeading = lines.slice(0, firstHeadingIndex + 1).join('\n');
    const afterHeading = lines.slice(firstHeadingIndex + 1).join('\n');
    
    processedReview = `${beforeHeading}\n\nGenerated by deepsynthesis.us on ${generatedDate}\n\n${afterHeading}`;
  } else {
    // No heading found, add attribution at the beginning
    processedReview = `${reviewContent}\n\nGenerated by deepsynthesis.us on ${generatedDate}`;
  }
  
  return [
    // Start with the processed review content with attribution
    processedReview,
    '\n\n## References\n\n',
    brief.references.map((ref, index) => 
      `[${index + 1}] ${ref.text}`
    ).join('\n\n'),
    '\n\n## BibTeX\n\n```\n',
    brief.bibtex || 'No BibTeX available.',
    '\n```'
  ].join('');
};

/**
 * Convert brief content to HTML format (used for PDF conversion)
 */
export const briefToHtml = (brief: Brief): string => {
  const referencesHtml = brief.references.map((ref, index) => 
    `<p>[${index + 1}] ${ref.text}</p>`
  ).join('');

  return `
    <html>
      <head>
        <title>${brief.title}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 40px; }
          h1 { font-size: 24px; margin-bottom: 10px; }
          h2 { font-size: 20px; margin-top: 20px; margin-bottom: 10px; }
          .date { color: #666; margin-bottom: 20px; }
          pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }
        </style>
      </head>
      <body>
        <div>${brief.review ? brief.review.replace(/\n/g, '<br>') : 'No review content available.'}</div>
        <p class="date">Generated by deepsynthesis.us on ${formatDate(new Date())}</p>
        <h2>References</h2>
        <div>${referencesHtml}</div>
        <h2>BibTeX</h2>
        <pre>${brief.bibtex || 'No BibTeX available.'}</pre>
      </body>
    </html>
  `;
};

/**
 * Export brief to markdown file
 */
export const exportBriefToMarkdown = (brief: Brief): void => {
  const markdownContent = briefToMarkdown(brief);
  const blob = new Blob([markdownContent], { type: 'text/markdown' });
  downloadBlob(blob, `${brief.title.replace(/\s+/g, '_')}.md`);
};

/**
 * Parse markdown content to identify headings and other formatting
 * @param text The text to parse
 * @returns An array of objects with text and formatting information
 */
const parseMarkdownForPdf = (text: string): Array<{
  text: string;
  isHeading1?: boolean;
  isHeading2?: boolean;
  isCodeBlock?: boolean;
  isBold?: boolean;
  isItalic?: boolean;
}> => {
  const lines = text.split('\n');
  const result = [];
  
  let inCodeBlock = false;
  
  for (const line of lines) {
    // Check for code block markers
    if (line.trim().startsWith('```')) {
      inCodeBlock = !inCodeBlock;
      continue; // Skip the marker line itself
    }
    
    if (inCodeBlock) {
      result.push({
        text: line,
        isCodeBlock: true
      });
      continue;
    }
    
    // Check for headings
    if (line.startsWith('# ')) {
      result.push({
        text: line.substring(2),
        isHeading1: true
      });
    } else if (line.startsWith('## ')) {
      result.push({
        text: line.substring(3),
        isHeading2: true
      });
    } else if (line.trim() === '') {
      // Empty line for spacing
      result.push({ text: '' });
    } else {
      // Process inline formatting (bold, italic)
      let processedText = line;
      
      // Check for bold text (surrounded by **)
      const boldMatches = line.match(/\*\*(.*?)\*\*/g);
      if (boldMatches) {
        for (const match of boldMatches) {
          const content = match.substring(2, match.length - 2);
          result.push({
            text: content,
            isBold: true
          });
          processedText = processedText.replace(match, ''); // Remove processed part
        }
      }
      
      // Check for italic text (surrounded by *)
      const italicMatches = processedText.match(/\*(.*?)\*/g);
      if (italicMatches) {
        for (const match of italicMatches) {
          const content = match.substring(1, match.length - 1);
          result.push({
            text: content,
            isItalic: true
          });
          processedText = processedText.replace(match, ''); // Remove processed part
        }
      }
      
      // Add remaining text if any
      if (processedText.trim()) {
        result.push({ text: processedText });
      }
    }
  }
  
  return result;
};

/**
 * Export brief to PDF file
 */
export const exportBriefToPdf = async (brief: Brief): Promise<void> => {
  // Create a new PDF document
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();
  const margin = 20;
  const contentWidth = pageWidth - (margin * 2);
  
  // Set initial position
  let yPos = margin;
  
  // Process review content with markdown formatting
  doc.setTextColor(0, 0, 0);
  const reviewText = brief.review || 'No review content available.';
  
  // Split review into paragraphs
  const reviewParagraphs = reviewText.split('\n\n');
  
  // Track if we've added the attribution line
  let attributionAdded = false;
  
  for (const paragraph of reviewParagraphs) {
    // Parse markdown in this paragraph
    const parsedContent = parseMarkdownForPdf(paragraph);
    
    for (const item of parsedContent) {
      // Apply appropriate styling based on content type
      if (item.isHeading1) {
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(20);
        
        // Ensure long headings are wrapped
        const splitHeading = doc.splitTextToSize(item.text, contentWidth);
        doc.text(splitHeading, margin, yPos);
        yPos += (splitHeading.length * 10);
        
        // Add attribution line after the first h1
        if (!attributionAdded) {
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(12);
          doc.setTextColor(100, 100, 100);
          
          const attributionText = `Generated by deepsynthesis.us on ${formatDate(new Date())}`;
          doc.text(attributionText, margin, yPos);
          yPos += 10;
          
          // Reset text color
          doc.setTextColor(0, 0, 0);
          
          attributionAdded = true;
        }
      } else if (item.isHeading2) {
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(16);
        
        // Ensure long headings are wrapped
        const splitHeading = doc.splitTextToSize(item.text, contentWidth);
        doc.text(splitHeading, margin, yPos);
        yPos += (splitHeading.length * 8);
      } else if (item.isCodeBlock) {
        doc.setFont('courier', 'normal');
        doc.setFontSize(10);
        doc.setTextColor(80, 80, 80);
        
        // Split code to fit on page
        const splitCode = doc.splitTextToSize(item.text, contentWidth);
        doc.text(splitCode, margin, yPos);
        yPos += (splitCode.length * 5);
        
        // Reset to normal text style
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(12);
        doc.setTextColor(0, 0, 0);
      } else if (item.isBold) {
        doc.setFont('helvetica', 'bold');
        
        // Ensure long bold text is wrapped
        const splitBold = doc.splitTextToSize(item.text, contentWidth);
        doc.text(splitBold, margin, yPos);
        yPos += (splitBold.length * 7);
        
        doc.setFont('helvetica', 'normal');
      } else if (item.isItalic) {
        doc.setFont('helvetica', 'italic');
        
        // Ensure long italic text is wrapped
        const splitItalic = doc.splitTextToSize(item.text, contentWidth);
        doc.text(splitItalic, margin, yPos);
        yPos += (splitItalic.length * 7);
        
        doc.setFont('helvetica', 'normal');
      } else if (item.text.trim() === '') {
        // Empty line for spacing
        yPos += 5;
      } else {
        // Regular text
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(12);
        
        // Split text to fit on page
        const splitText = doc.splitTextToSize(item.text, contentWidth);
        doc.text(splitText, margin, yPos);
        yPos += (splitText.length * 7);
      }
      
      // Check if we need a new page
      if (yPos > 270) {
        doc.addPage();
        yPos = margin;
      }
    }
    
    // Add space between paragraphs
    yPos += 5;
  }
  
  // If no h1 was found, add the attribution line here
  if (!attributionAdded) {
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    doc.setTextColor(100, 100, 100);
    
    const attributionText = `Generated by deepsynthesis.us on ${formatDate(new Date())}`;
    doc.text(attributionText, margin, yPos);
    yPos += 15;
    
    // Reset text color
    doc.setTextColor(0, 0, 0);
  }
  
  // Add References heading
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(18);
  doc.text('References', margin, yPos);
  yPos += 10;
  
  // Add each reference
  doc.setFont('helvetica', 'normal');
  doc.setFontSize(12);
  
  brief.references.forEach((ref, index) => {
    const refText = `[${index + 1}] ${ref.text}`;
    const splitRef = doc.splitTextToSize(refText, contentWidth);
    
    // Check if we need a new page
    if (yPos + (splitRef.length * 7) > 270) {
      doc.addPage();
      yPos = margin;
    }
    
    doc.text(splitRef, margin, yPos);
    yPos += (splitRef.length * 7) + 5;
  });
  
  // Add BibTeX section if available
  if (brief.bibtex) {
    // Check if we need a new page
    if (yPos > 250) {
      doc.addPage();
      yPos = margin;
    }
    
    // Add BibTeX heading
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(18);
    doc.text('BibTeX', margin, yPos);
    yPos += 10;
    
    // Add BibTeX content with monospace font
    doc.setFont('courier', 'normal');
    doc.setFontSize(10);
    doc.setTextColor(80, 80, 80);
    
    const bibtexText = brief.bibtex || 'No BibTeX available.';
    const splitBibtex = doc.splitTextToSize(bibtexText, contentWidth);
    doc.text(splitBibtex, margin, yPos);
  }
  
  // Save the PDF
  doc.save(`${brief.title.replace(/\s+/g, '_')}.pdf`);
};

/**
 * Helper function to download a blob as a file
 */
export const downloadBlob = (blob: Blob, fileName: string): void => {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = fileName;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

/**
 * Export brief to the specified format
 */
export const exportBrief = async (brief: Brief, format: ExportFormat): Promise<void> => {
  try {
    switch (format) {
      case 'md':
        exportBriefToMarkdown(brief);
        break;
      case 'pdf':
        await exportBriefToPdf(brief);
        break;
      default:
        throw new Error(`Unsupported export format: ${format}`);
    }
  } catch (error) {
    console.error(`Error exporting brief to ${format}:`, error);
    throw new Error(`Failed to export brief to ${format}`);
  }
}; 